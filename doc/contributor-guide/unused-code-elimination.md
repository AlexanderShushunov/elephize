### Вкратце о принципах работы удаления неиспользуемого кода (unused code elimination, далее UCE)

Любая программа может быть представлена в виде набора __объявлений__ (declaration) неких сущностей (переменных, функций)
и __использований__ (usage) объявленных сущностей в коде. Объявления могут содержать другие объявления и использования.
Таким образом:
- Связность объявлений представляем в виде направленного __графа использований__ (usage graph), в котором
  вершинами будут объявления, а ребрами - использования.
- В графе использований могут быть циклические зависимости.

Поскольку в javascript объявления функций могут содержать другие объявления функций, но при этом действуют правила 
доступа согласно __областям видимости__ (scope), этот факт также нужно учесть в модели данных:
- По умолчанию и изначально мы работаем в области видимости текущего модуля (module scope).
- Объявление функции порождает новую область видимости.
- Внутри области видимости существует список объявленных переменных и функций. Также можно достучаться до списков 
  объявленных идентификаторов в верхних областях.

Таким образом, архитектурно в слое UCE имеется две основных сущности:
- Граф использований
- Дерево областей видимости с определенным набором правил доступа.

Ребро в графе использований порождается в том случае, если для получения значения переменной или выполнения функции
требуется значение из другой переменной или функции в текущей или одной из верхних областей видимости.

Нужно определить четкий критерий того, используется ли данная переменная или функция. Для этого введем понятие 
особой глобальной __терминальной вершины__ (обозначим ее аббревиатурой GTN - global terminal node) на уровне 
модуля со следующими свойствами:
- GTN является единственной, в es-модуле не может быть двух GTN.
- Если от GTN до некоторой вершины X существует ребро, значит объявление, соответствующее вершине X, используется в коде.
- Ребра из GTN должны порождаться к тем вершинам, которые передают свое значение в следующие конструкции:
    - export (function/const)
    - console.log()
    - иные (библиотечные) средства вывода или передачи результата.
    - ... список может быть неполон.

Аналогичным образом введем понятие __локальной терминальной вершины__ (LTN - local terminal node), со следующими свойствами:
- LTN определяется на уровне объявления функции. У функции может быть одна и только одна LTN.
- Не может быть двух функций с одинаковыми LTN.
- Если от LTN до некоторой вершины X существует ребро, значит объявление, соответствующее вершине X, используется
  в коде функции и может быть удалено только вместе со всей функцией.

Когда в коде происходит вызов функции, создается вершина, соответствующая этому вызову. При этом важен тот факт, что
переменные или функции, которые используют результат вычисления функции, должны из соответсвующих вершин породить
ребра не только к вершине объявления функции, но и __к ее локальной терминальной вершине__. Это делается как раз
для того, чтобы понимать сценарий использования функции и потенциальную возможность удаления всей функции или
только некоторых из ее выражений.

В каждой вершине заведем отметку об обходе - простой булевский флаг. С учетом всего вышенаписанного можно сформулировать
__алгоритм UCE__ как обыкновенный обход графа в глубину начиная с глобальной терминальной вершины. После обхода мы можем
достоверно судить используется ли идентификатор по наличию отметки об обходе в соответствующей вершине.

__Особый случай__: в js допустим сценарий, когда объявление происходит ПОСЛЕ использования (т.е. hoisting). Для поддержки этого
сценария вводим два типа вершин в графе:
- BoundNode - уже связанная с объявлением вершина, готовая к использованию.
- BindPendingNode - может быть создана только при регистрации использования до объявления. Если вершина была использована,
  но не была объявлена до конца файла - это явная ошибка компиляции. Если же объявление найдено, в этот момент вершина преобразуется
  к предыдущему типу и работает соответственно.
  