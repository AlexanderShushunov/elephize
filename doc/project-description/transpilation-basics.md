### Базовые основы построения elephize

Microsoft дало нам не только typescript как язык, но еще и богатые инструменты для 
работы с ним. Использование готового парсера и тайпчекера явно позволило бы упростить
и ускорить разработку. Рассмотрим типичные сценарии использования typescript compiler
API.

Основной сценарий - это парсинг файла в AST с последующим обходом этого AST в глубину
и генерацией кода на целевом языке исходя из того, что мы находим в AST. Что нужно 
сделать для этого?

Во-первых, создаем объект Program:

```typescript
const program = ts.createProgram(filenames, options, compilerHost);
```

В `filenames` передаем набор имен файлов, в `options` - опции компилятора (то, что лежит
в секции `compilerOptions` в вашем tsconfig.json). Переменная `compilerHost` содержит
объект `CompilerHost`, который описывается в документации следующим образом: 
“CompilerHost is a user system API for reading files, checking directories, and case 
sensitivity”. `CompilerHost` можно либо взять готовый, вызвав функцию
`ts.createCompilerHost`, либо создать самостоятельно, если вам нужна кастомизация
поведения компилятора.

Из полученного объекта класса `Program` можно во-первых получить тайпчекер, из которого
мы в том числе будем брать выведенные типы (`program.getTypeChecker()`), во-вторых -
получить набор объектов `SourceFile`, соответствующих всем обработанным файлам
(`program.getSourceFiles()`). Объект `SourceFile` - это корневая нода AST файла. 
Заметим, что тайпчекер в целом является опциональным объектом, т.е. можно бегать по
AST и без его использования, но тогда информация о типах будет недоступна.

#### Какие есть возможности обхода у нод AST?
1) Все ноды имеют метод `node.getChildren()`, позволяющий достать всех непосредственных
   потомков ноды
2) Каждая нода имеет свойство `kind`, относящееся к типу `ts.SyntaxKind` - это простое
   числовое перечисление, конкретные названия, соответствующие идентификатору типа 
   ноды, можно узнать в файле `typescript.d.ts`, который содержится в пакете typescript.
3) При необходимости можно получить текстовое представление ноды через `node.getText()`.
   Это не всегда работает нужным образом для сложных конструкций (ведь нам не нужно
   получать js-представление конструкции), но прекрасно работает для литералов и 
   идентификаторов.

Таким образом, мы можем организовать обход в глубину, и в зависимости от типа ноды
обрабатывать ее тем или иным образом. Базовая функция обхода в нашем транспиляторе
будет называться `renderNode` и будем иметь примерно следующий вид:
```typescript
function renderNode(node: ts.Node | undefined, context: Context<Declaration>): string {
    // if (node.kind === ...) { ... custom handler ... }
    
    return node
        ? node.getChildren()
            .map((child) => renderNode(child, context)) // Зовем функцию рекурсивно для всех детей
            .join('')
        : '';
}
```
`Context` здесь - это некоторый объект с дополнительной информацией, который мы
передаем во все обработчики. Он пригодится нам например для обработки замыканий и
вложенности.

[Далее: Транспиляция базового синтаксиса](./basic-syntax.md)